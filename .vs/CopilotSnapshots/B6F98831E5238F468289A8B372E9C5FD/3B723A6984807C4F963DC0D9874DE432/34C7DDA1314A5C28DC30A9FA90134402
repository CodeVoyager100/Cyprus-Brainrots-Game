<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cyprus Brainrot Game</title>
    <style>
        /* merged body rules to avoid duplicate declarations */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-image: url('images/background.png');
            background-color: #000;
            color: rgb(255, 255, 255);
            padding-left: 20px;
        }

        .guide {
            color: white;
        }
        #coins-display {
            font-size: 30px;
            margin: 20px;
            color: white;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
        }

        .skin-card {
            display: inline-block;
            background-color: #f4f4f4;
            border: 2px solid #ccc;
            padding: 10px;
            margin: 10px;
            text-align: center;
            border-radius: 12px;
            width: 180px;
        }

        .skin-img {
            width: 100%;
            border-radius: 10px;
        }

        .map-buttons-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
        }

        .map-button {
            padding: 10px 20px;
            background-color: #ffcc00;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .map-button:hover {
            transform: scale(1.1);
        }

        .menu {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }

        .btn {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }

        .btn:hover {
            background-color: #666;
        }

        #gameCanvas {
            width: 100vw;
            height: 100vh; /* ensure canvas fills viewport but not huge values */
            display: block;
        }

#joystick-container {
  position: fixed;
  bottom: 30px;
  left: 30px;
  z-index: 9999;
}

#joystick-base {
  width: 120px;
  height: 120px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 50%;
  position: relative;
  touch-action: none;
}
    @keyframes zoom {
  0% { transform: scale(1); }
  100% { transform: scale(1.2); }
}
.confetti {
  position: absolute;
  width: 10px;
  height: 10px;
  background-color: #f00;
  opacity: 0.7;
}
#joystick-stick {
  width: 60px;
  height: 60px;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 50%;
  position: absolute;
  left: 30px;
  top: 30px;
  touch-action: none;
}

#debug-status {
  position: fixed;
  right: 10px;
  top: 10px;
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 8px 10px;
  font-family: monospace;
  font-size: 14px;
  border-radius: 6px;
  z-index: 99999;
  max-width: 320px;
  pointer-events: none;
}

    </style>
</head>
<body>
    <div id="html-part">
    <div class="guide">    
        <br><br><br><br><br><br><br><br><br>
    <p> Welcome to Cyprus Brainrot Game! 
        <br> Use the white joystick to move your character and red joystic to shoot at the Enemy. 
        <br> Collect coins and unlock skins in the Bazaar! [Not yet available]
        <br> Click "battle!" to start a game.
        <br> Use the joystick on mobile or tablet devices.
        <br> Use arrow keys or WASD to move on desktop and mouse click to shoot.
        <br> Enjoy the game and have fun!
    </p>
    </div>
    <div id="lootbox-popup" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:linear-gradient(135deg,#FFD700,#FFAA00); padding:30px; border-radius:20px; border:5px solid white; z-index:1000; text-align:center; box-shadow:0 0 30px rgba(255,215,0,0.7);">
  <h2 style="color:#FFF; text-shadow:2px 2px 4px #000;">LOOT BOX REWARD!</h2>
  <div id="lootbox-content" style="font-size:24px; margin:20px 0;"></div>
  <button id="lootbox-ok" style="background:#FFF; border:none; padding:10px 20px; border-radius:10px; font-weight:bold;">OK</button>
</div>
    <div id="coins-display"></div>
    <div id="skins-container"></div>
    <div id="map-selection" class="map-buttons-container"></div>

    <div class="menu">
        <button class="btn" id="start-btn">🎮 battle!</button>
        <button class="btn" id="shop-btn">🛒 Bazaar</button>
        <button class="btn" id="rank-btn">🏆 Glory Line</button>
        <button class="btn" id="switch-player-btn">🔁 Switch Player</button>
    </div> 

    <div id="rankings-container" style="display:none; position:absolute; top:60px; left:50%; transform:translateX(-50%); background:#222; color:#fff; padding:24px 32px; border-radius:16px; z-index:20; min-width:320px; text-align:center;">
        <h2>🏆 Glory Line</h2>
        <div id="owned-players" style="text-align:left; margin-bottom:12px;"></div>
        <ol id="ladder-list" style="text-align:left; margin:0 auto; max-width:300px;"></ol>
        <div id="rank-prize-message" style="margin-top:10px; color:#ffcc00;"></div>
        <button class="btn" id="close-rank-btn" style="margin-top:16px;">Close</button>
    </div>
    <canvas id="gameCanvas"></canvas>

  <!-- HTML μέρος (βάζεις αυτό στο body σου) -->
<div id="joystick-container" style="display: block;">
  <div id="joystick-base">
    <div id="joystick-stick"></div>
  </div>
</div>

<!-- Add to your HTML -->
<div id="shoot-joystick-container" style="display: block; position: fixed; bottom: 30px; right: 30px; z-index: 9999;">
  <div id="shoot-joystick-base" style="width: 120px; height: 120px; background: rgba(0, 0, 0, 0.3); border-radius: 50%; position: relative; touch-action: none;">
    <div id="shoot-joystick-stick" style="width: 60px; height: 60px; background: rgba(255, 100, 100, 0.8); border-radius: 50%; position: absolute; left: 30px; top: 30px; touch-action: none;"></div>
  </div>
</div>

<!-- debug status box -->
<div id="debug-status">loading...</div>
    </div>

    <script>
    (function () {
        'use strict';

        function setDebug(msg) {
            try { var el = document.getElementById('debug-status'); if (el) el.textContent = msg; } catch (e) { console.warn('setDebug failed', e); }
        }

        // global error handler to surface errors to user
        window.onerror = function (message, source, lineno, colno, error) {
            console.error('Window error:', message, 'at', source + ':' + lineno + ':' + colno, error);
            setDebug('Script error: ' + message);
            try {
                var disp = document.getElementById('coins-display');
                if (disp) disp.innerText = 'Script error: ' + message;
            } catch (e) {}
            return false; // allow default handling too
        };

        try {

        setDebug('script loaded');
        console.log('game script loaded');

        const gameCanvas = document.getElementById('gameCanvas');
        if (!gameCanvas) throw new Error('Missing canvas element with id "gameCanvas"');
        const ctx = gameCanvas.getContext('2d');

        function resizeCanvas() {
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
            // regenerate obstacles to cover new screen
            generateObstacles();
            setDebug('resized: ' + gameCanvas.width + 'x' + gameCanvas.height);
        }

        // declare obstacles early so generateObstacles() can be called during initialization
        let loopStarted = false; // flag for debug logging
        let obstacles = [];

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let playerCoins = parseInt(localStorage.getItem('coins'), 10) || 1000;
        let unlockedSkins = JSON.parse(localStorage.getItem('unlockedSkins') || '[]');
        let unlockedPlayers = JSON.parse(localStorage.getItem('unlockedPlayers') || '["default"]');
        let selectedPlayerId = localStorage.getItem('selectedPlayerId') || 'default';

        // compatibility: map old id 'speedster' to new 'tornader' if present in storage
        unlockedPlayers = unlockedPlayers.map(id => id === 'speedster' ? 'tornader' : id);
        if (selectedPlayerId === 'speedster') selectedPlayerId = 'tornader';
        // ensure uniqueness
        unlockedPlayers = Array.from(new Set(unlockedPlayers));

        const playersData = {
            default: { id: 'default', name: 'Scorpios', img: 'images/ScorpiosSouvlak.png', hp: 13, speed: 2.5, laserDamage: 1, size: 55, laserRange: 300, price: 0 },
            tornader: { id: 'tornader', name: 'Tornader', img: 'images/rot2.png', hp: 16, speed: 9, laserDamage: 2, size: 55, laserRange: 300, price: 1500 },
            lazerman: { id: 'lazerman', name: 'Lazerman', img: 'images/rot1.png', hp: 14, speed: 10, laserDamage: 1, size: 55, laserRange: 500, price: 500 },
            kleftikomegazord: { id: 'kleftikomegazord', name: 'Kleftikomegazord', img: 'images/rot3.png', hp: 20, speed: 1.6, laserDamage: 3, size: 60, laserRange: 300, price: 2000 }
        };

        const playerImg = new Image();
        playerImg.src = (playersData[selectedPlayerId] || playersData.default).img;
        const AIImg = new Image();
        AIImg.src = 'images/pkiotisfournos.png';

        let gameStarted = false;
        let lasers = [];
        let aiLasers = [];

        let playerLevel = parseInt(localStorage.getItem('playerLevel'), 10) || 1;

        // helper: find a free spawn position (not colliding with obstacles)
        function getSpawnPosition(size) {
            // try several times to find a random free cell near center first then anywhere
            const maxAttempts = 500;
            const padding = 10;
            // helper to test rect collision with obstacles
            function isFree(x, y) {
                const rect = { x: x, y: y, size: size };
                for (let obs of obstacles) {
                    if (checkCollisionWithRect(rect, obs)) return false;
                }
                // keep some distance from edges
                if (x < padding || y < padding || x + size > gameCanvas.width - padding || y + size > gameCanvas.height - padding) return false;
                return true;
            }
            // try around center first
            const centerX = Math.floor(gameCanvas.width / 2);
            const centerY = Math.floor(gameCanvas.height / 2);
            for (let i = 0; i < 100; i++) {
                const rx = centerX + (Math.floor(Math.random() * 401) - 200);
                const ry = centerY + (Math.floor(Math.random() * 401) - 200);
                if (isFree(rx, ry)) return { x: rx, y: ry };
            }
            // fallback: random across canvas
            for (let i = 0; i < maxAttempts; i++) {
                const rx = Math.floor(Math.random() * (gameCanvas.width - size - padding * 2)) + padding;
                const ry = Math.floor(Math.random() * (gameCanvas.height - size - padding * 2)) + padding;
                if (isFree(rx, ry)) return { x: rx, y: ry };
            }
            // last resort: return center clamped
            return { x: Math.max(padding, Math.min(centerX, gameCanvas.width - size - padding)), y: Math.max(padding, Math.min(centerY, gameCanvas.height - size - padding)) };
        }

        // generate initial obstacles
        generateObstacles();

        // Initialize player and AI with safe spawn positions
        const selectedData = playersData[selectedPlayerId] || playersData.default;
        const initialPos = getSpawnPosition(selectedData.size);
        let player = {
            x: initialPos.x,
            y: initialPos.y,
            size: selectedData.size,
            color: 'blue',
            speed: selectedData.speed,
            hp: selectedData.hp,
            shootCooldown: 0,
            laserDamage: selectedData.laserDamage || 1,
            laserRange: selectedData.laserRange || 300
        };

        const aiPos = getSpawnPosition(50);
        // AI configured to wander (does not actively chase the player) and be easier
        let ai = {
            x: aiPos.x,
            y: aiPos.y,
            size: 50,
            color: 'green',
            speed: 1.2, // slower to make it easier
            hp: 8,
            shootCooldown: 0,
            vx: 0,
            vy: 0,
            pauseTimer: 0,
            accuracy: 0.35, // lower accuracy -> more misses
            targetX: aiPos.x,
            targetY: aiPos.y,
            targetTimer: 0
        };

        // keep previous player position for simple velocity estimation used for aiming
        let lastPlayerPos = { x: player.x, y: player.y };

        function saveState() {
            localStorage.setItem('coins', playerCoins);
            localStorage.setItem('unlockedSkins', JSON.stringify(unlockedSkins));
            localStorage.setItem('unlockedPlayers', JSON.stringify(unlockedPlayers));
            localStorage.setItem('playerLevel', playerLevel);
            localStorage.setItem('selectedPlayerId', selectedPlayerId);
        }

        function openLootBox() {
            const roll = Math.random() * 100;
            if (roll < 30) return { type: 'nothing', message: 'Better luck next time! \uD83C\uDF40' };
            if (roll < 80) return { type: 'levels', amount: 2, message: '\uD83D\uDD25 +2 Levels! \uD83D\uDD25' };
            if (roll < 81) return { type: 'rank', message: '✨ RANK UP! ✨' };
            if (roll < 90) return { type: 'coins', amount: 100, message: '\uD83D\uDCB0 +100 Coins! \uD83D\uDCB0' };
            if (roll < 95) return { type: 'coins', amount: 200, message: '\uD83D\uDCB0 +200 Coins! \uD83D\uDCB0' };
            return { type: 'coins', amount: 500, message: '\uD83D\uDCB0 +500 Coins! \uD83D\uDCB0' };
        }

        function showLootBoxResults(reward) {
            const popup = document.getElementById('lootbox-popup');
            const content = document.getElementById('lootbox-content');
            const okBtn = document.getElementById('lootbox-ok');
            if (!popup || !content) return;
            if (reward.type === 'rank') {
                content.innerHTML = '<div style="animation:zoom 0.5s infinite alternate;">' + reward.message + '</div><div>New rank: ' + getCurrentRank(playerLevel).name + '</div>';
                popup.style.background = 'linear-gradient(135deg,#8A2BE2,#9370DB)';
            } else {
                content.textContent = reward.message || 'You got something!';
                popup.style.background = 'linear-gradient(135deg,#FFD700,#FFAA00)';
            }
            okBtn.onclick = function () { popup.style.display = 'none'; };
            popup.style.display = 'block';
        }

        // obstacles will be generated to fill the screen but be fewer and more chaotic
        function generateObstacles() {
            obstacles.length = 0;
            const cell = 100; // grid cell size (smaller than before to place smaller obstacles)
            const cols = Math.ceil(gameCanvas.width / cell);
            const rows = Math.ceil(gameCanvas.height / cell);
            const totalCells = cols * rows;
            // slightly fewer obstacles but smaller in size
            const count = Math.max(3, Math.floor(totalCells * 0.06)); // ~6% of grid
            for (let i = 0; i < count; i++) {
                // smaller and less variable obstacles
                const w = Math.floor(Math.random() * 90) + 30; // 30..119
                const h = Math.floor(Math.random() * 80) + 30; // 30..109
                const x = Math.floor(Math.random() * Math.max(1, gameCanvas.width - w));
                const y = Math.floor(Math.random() * Math.max(1, gameCanvas.height - h));
                const type = Math.random() < 0.5 ? 'lake' : 'brick';
                obstacles.push({ x, y, width: w, height: h, type });
            }
            // add a few small chaotic debris pieces (reduced)
            const smallCount = Math.max(2, Math.floor(totalCells * 0.02));
            for (let i = 0; i < smallCount; i++) {
                const w = Math.floor(Math.random() * 35) + 6;
                const h = Math.floor(Math.random() * 35) + 6;
                const x = Math.floor(Math.random() * Math.max(1, gameCanvas.width - w));
                const y = Math.floor(Math.random() * Math.max(1, gameCanvas.height - h));
                const type = Math.random() < 0.5 ? 'lake' : 'brick';
                obstacles.push({ x, y, width: w, height: h, type });
            }
            // debug: log obstacle count and show on-screen
            console.log('generateObstacles: created', obstacles.length, 'obstacles');
            setDebug('obstacles: ' + obstacles.length);
        }

        function showCoins() {
            const rank = getCurrentRank(playerLevel);
            const display = document.getElementById('coins-display');
            if (display) display.innerText = '\uD83D\uDCB0 Coins: ' + playerCoins + '  |  \uD83C\uDFC5 Rank: ' + rank.name + '  |  \uD83D\uDD3C Level: ' + playerLevel;
            display.style.display = 'block';
        }

        async function loadSkins() {
            const container = document.getElementById('skins-container');
            if (!container) return;
            container.innerHTML = '';
            try {
                const res = await fetch('skins.json');
                const skins = await res.json();
                skins.forEach(function (skin) {
                    const div = document.createElement('div');
                    div.className = 'skin-card';
                    const img = document.createElement('img'); img.src = skin.image; img.className = 'skin-img';
                    const h3 = document.createElement('h3'); h3.textContent = skin.name;
                    const p = document.createElement('p'); p.textContent = skin.character;
                    const btn = document.createElement('button');
                    if (unlockedSkins.includes(skin.id) || skin.price === 0) {
                        btn.textContent = '✔️ Owned'; btn.disabled = true;
                    } else {
                        btn.textContent = 'Buy for ' + skin.price + ' coins';
                        btn.addEventListener('click', function () { buySkin(skin.id, skin.price); });
                    }
                    div.appendChild(img); div.appendChild(h3); div.appendChild(p); div.appendChild(btn);
                    container.appendChild(div);
                });
            } catch (e) {
                // ignore missing skins.json
                console.warn('loadSkins failed', e);
            }

            // Add player purchase cards for available characters
            Object.keys(playersData).forEach(function (pid) {
                if (pid === 'default') return;
                const pdata = playersData[pid];
                const playerDiv = document.createElement('div'); playerDiv.className = 'skin-card';
                const imgEl = document.createElement('img'); imgEl.src = pdata.img; imgEl.className = 'skin-img';
                const h3El = document.createElement('h3'); h3El.textContent = pdata.name;
                const pEl = document.createElement('p'); pEl.textContent = 'Speed: ' + pdata.speed + ', HP: ' + pdata.hp + ', Damage: ' + pdata.laserDamage + ', Range: ' + pdata.laserRange + '.';
                const btnEl = document.createElement('button');
                if (unlockedPlayers.includes(pdata.id)) { btnEl.textContent = '✔️ Owned'; btnEl.disabled = true; }
                else { btnEl.textContent = 'Buy ' + pdata.name + ' for ' + (pdata.price || 1000) + ' coins'; btnEl.addEventListener('click', function () { buyPlayer(pdata.id, pdata.price || 1000); }); }
                playerDiv.appendChild(imgEl); playerDiv.appendChild(h3El); playerDiv.appendChild(pEl); playerDiv.appendChild(btnEl);
                container.appendChild(playerDiv);
            });
        }

        function buySkin(id, price) {
            if (playerCoins >= price) {
                playerCoins -= price;
                unlockedSkins.push(id);
                saveState();
                showCoins();
                loadSkins();
                alert('Skin unlocked!');
            } else {
                alert('Not enough coins \uD83D\uDE22');
            }
        }

        function buyPlayer(id, price) {
            if (unlockedPlayers.includes(id)) return;
            if (playerCoins >= price) {
                playerCoins -= price;
                unlockedPlayers.push(id);
                saveState();
                showCoins();
                loadSkins();
                alert('Player unlocked! Use Switch Player to equip.');
            } else {
                alert('Not enough coins \uD83D\uDE22');
            }
        }

        async function loadMaps() {
            try {
                const res = await fetch('images/maps.json');
                const maps = await res.json();
                const mapContainer = document.getElementById('map-selection');
                if (!mapContainer) return;
                mapContainer.innerHTML = '';
                maps.forEach(function (map) { const btn = document.createElement('button'); btn.className = 'map-button'; btn.innerText = map.name; btn.addEventListener('click', function () { selectMap(map); }); mapContainer.appendChild(btn); });
            } catch (e) {
                // ignore
            }
        }

        function selectMap(map) { console.log('Selected map: ' + map.name); }

        function updatePlayerFromSelection() {
            const data = playersData[selectedPlayerId] || playersData.default;
            // Update properties but keep position
            const oldX = player.x, oldY = player.y;
            player.size = data.size;
            player.speed = data.speed;
            player.hp = data.hp;
            player.laserDamage = data.laserDamage || 1;
            player.laserRange = data.laserRange || 300;
            player.x = oldX;
            player.y = oldY;
            playerImg.src = data.img;
            saveState();
        }

        function drawPlayer() { if (playerImg.complete && playerImg.naturalWidth !== 0) ctx.drawImage(playerImg, player.x, player.y, player.size, player.size); else { ctx.fillStyle = player.color; ctx.fillRect(player.x, player.y, player.size, player.size); } }

        function drawAI() { if (AIImg.complete && AIImg.naturalWidth !== 0) ctx.drawImage(AIImg, ai.x, ai.y, ai.size, ai.size); else { ctx.fillStyle = ai.color; ctx.fillRect(ai.x, ai.y, ai.size, ai.size); } }

        function drawHP() { if (!gameStarted) return; ctx.save(); ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.fillText('Your HP: ' + player.hp, 10, 25); ctx.fillText('Enemy HP: ' + ai.hp, 10, 90); ctx.restore(); }

        // Add obstacle hit alert throttling (non-blocking)
        let lastObstacleAlert = 0;
        function notifyObstacleHit() {
            const now = Date.now();
            if (now - lastObstacleAlert > 1000) { // throttle to 1s
                lastObstacleAlert = now;
                setDebug('Hit obstacle');
                setTimeout(function () { setDebug('running'); }, 1000);
            }
        }

        // improved AI: wander (does not chase player) until player enters 500px, then follow and shoot
        function updateAI() {
            // occasional pause to simulate human-like hesitation
            if (ai.pauseTimer > 0) { ai.pauseTimer--; return; }

            const centerAx = ai.x + ai.size/2; const centerAy = ai.y + ai.size/2;
            const centerPx = player.x + player.size/2; const centerPy = player.y + player.size/2;
            const distToPlayer = getDistance(centerAx, centerAy, centerPx, centerPy);

            if (distToPlayer <= 300) { // detection range reduced from 500 to 200
                // enter 'alert' mode: follow the player (player-like movement) and shoot more frequently
                // set a closer target (player pos)
                let dxRaw = centerPx - centerAx;
                let dyRaw = centerPy - centerAy;
                const thresh = 6;
                let inputX = 0, inputY = 0;
                if (Math.abs(dxRaw) > thresh) inputX = dxRaw > 0 ? 1 : -1;
                if (Math.abs(dyRaw) > thresh) inputY = dyRaw > 0 ? 1 : -1;

                // move like a player (axis-aligned)
                const oldX = ai.x, oldY = ai.y;
                let mvx = inputX, mvy = inputY;
                const mag = Math.hypot(mvx, mvy);
                if (mag > 1) { mvx /= mag; mvy /= mag; }
                ai.x += mvx * ai.speed * 1.1; // slightly faster while chasing
                for (let obs of obstacles) { if (checkCollisionWithRect(ai, obs)) { ai.x = oldX; break; } }
                ai.y += mvy * ai.speed * 1.1;
                for (let obs of obstacles) { if (checkCollisionWithRect(ai, obs)) { ai.y = oldY; break; } }

                // shooting behavior: more aggressive but still limited accuracy
                if (ai.shootCooldown <= 0) {
                    // predictive aim with modest lead
                    const pvx = (player.x - lastPlayerPos.x);
                    const pvy = (player.y - lastPlayerPos.y);
                    const lead = 4;
                    const aimX = centerPx + pvx * lead;
                    const aimY = centerPy + pvy * lead;
                    const aimDx = aimX - centerAx;
                    const aimDy = aimY - centerAy;
                    const aimAngle = Math.atan2(aimDy, aimDx);
                    const maxSpread = 1.0;
                    const spread = (1 - (ai.accuracy || 0.35)) * maxSpread * (distToPlayer / 700);
                    const noisyAngle = aimAngle + (Math.random() - 0.5) * spread;
                    const speed = 12;
                    const vx = Math.cos(noisyAngle) * speed;
                    const vy = Math.sin(noisyAngle) * speed;
                    aiLasers.push({ x: ai.x + ai.size/2, y: ai.y + ai.size/2, vx, vy, life: 60, damage: 1 });
                    ai.shootCooldown = 12 + Math.floor(Math.random() * 28); // faster shooting when alerted
                } else ai.shootCooldown--;

                return; // skip wander logic
            }

            // wander logic (unchanged)
            // If target expired or reached, pick a new wander target away from the player
            ai.targetTimer = (ai.targetTimer || 0) - 1;
            const reached = getDistance(ai.x, ai.y, ai.targetX, ai.targetY) < 12;
            if (!ai.targetX || ai.targetTimer <= 0 || reached) {
                let tries = 0;
                do {
                    const pos = getSpawnPosition(ai.size);
                    ai.targetX = pos.x;
                    ai.targetY = pos.y;
                    tries++;
                } while (getDistance(ai.targetX, ai.targetY, player.x, player.y) < 180 && tries < 10);
                ai.targetTimer = 60 + Math.floor(Math.random() * 240);
            }

            // move toward target using player-like (axis-aligned) movement
            const dx = ai.targetX - ai.x;
            const dy = ai.targetY - ai.y;
            let inputX = 0, inputY = 0;
            const thresh = 6;
            if (Math.abs(dx) > thresh) inputX = dx > 0 ? 1 : -1;
            if (Math.abs(dy) > thresh) inputY = dy > 0 ? 1 : -1;

            let mvx = inputX, mvy = inputY;
            const mag = Math.hypot(mvx, mvy);
            if (mag > 1) { mvx /= mag; mvy /= mag; }

            const oldX2 = ai.x, oldY2 = ai.y;
            ai.x += mvx * ai.speed;
            // horizontal collision
            for (let obs of obstacles) { if (checkCollisionWithRect(ai, obs)) { ai.x = oldX2; break; } }
            ai.y += mvy * ai.speed;
            // vertical collision
            for (let obs of obstacles) { if (checkCollisionWithRect(ai, obs)) { ai.y = oldY2; break; } }

            // occasional small random jitter
            if (Math.random() < 0.02) {
                ai.x += (Math.random() - 0.5) * ai.speed * 0.8;
                ai.y += (Math.random() - 0.5) * ai.speed * 0.8;
            }

            // if ended up inside obstacle, revert and pause
            for (let obs of obstacles) {
                if (checkCollisionWithRect(ai, obs)) {
                    ai.x = oldX2; ai.y = oldY2;
                    ai.x += (Math.random() - 0.5) * ai.speed * 4;
                    ai.y += (Math.random() - 0.5) * ai.speed * 4;
                    if (Math.random() < 0.6) ai.pauseTimer = 6 + Math.floor(Math.random() * 12);
                    break;
                }
            }
        }

        const keysPressed = {};
        window.addEventListener('keydown', function (e) { const k = (e.key || '').toLowerCase(); if (k === '1') { playerCoins += 500; saveState(); showCoins(); return; } keysPressed[k] = true; });
        window.addEventListener('keyup', function (e) { keysPressed[(e.key || '').toLowerCase()] = false; });

        // joystick handling (only if elements present)
        const baseEl = document.getElementById('joystick-base');
        const stickEl = document.getElementById('joystick-stick');
        let dragging = false; let centerX = 0, centerY = 0; let movement = { x: 0, y: 0 };
        function updateStickPosition(x, y) { const dx = x - centerX; const dy = y - centerY; const distance = Math.min(Math.sqrt(dx * dx + dy * dy), 40); const angle = Math.atan2(dy, dx); const newX = Math.cos(angle) * distance; const newY = Math.sin(angle) * distance; if (stickEl) { stickEl.style.left = (30 + newX) + 'px'; stickEl.style.top = (30 + newY) + 'px'; } movement = { x: newX / 40, y: newY / 40 }; }
        function resetStick() { if (stickEl) { stickEl.style.left = '30px'; stickEl.style.top = '30px'; } movement = { x: 0, y: 0 }; }
        if (baseEl) { baseEl.addEventListener('touchstart', function (e) { dragging = true; const rect = baseEl.getBoundingClientRect(); centerX = rect.left + rect.width / 2; centerY = rect.top + rect.height / 2; }); baseEl.addEventListener('touchmove', function (e) { if (dragging) { e.preventDefault(); updateStickPosition(e.touches[0].clientX, e.touches[0].clientY); } }); baseEl.addEventListener('touchend', function () { dragging = false; resetStick(); }); }

        // shoot joystick
        const shootBase = document.getElementById('shoot-joystick-base');
        const shootStick = document.getElementById('shoot-joystick-stick');
        let shootDragging = false; let shootCenterX = 0, shootCenterY = 0; let shootDirection = { x: 0, y: 0 }; let lastShootTime = 0; const shootCooldown = 500;
        function updateShootStickPosition(x, y) { const dx = x - shootCenterX; const dy = y - shootCenterY; const distance = Math.min(Math.sqrt(dx * dx + dy * dy), 40); const angle = Math.atan2(dy, dx); const newX = Math.cos(angle) * distance; const newY = Math.sin(angle) * distance; if (shootStick) { shootStick.style.left = (30 + newX) + 'px'; shootStick.style.top = (30 + newY) + 'px'; } shootDirection = { x: newX / 40, y: newY / 40 }; const now = Date.now(); if (distance > 10 && now - lastShootTime > shootCooldown && player.shootCooldown <= 0) { autoShoot(); lastShootTime = now; } }
        function resetShootStick() { if (shootStick) { shootStick.style.left = '30px'; shootStick.style.top = '30px'; } shootDirection = { x: 0, y: 0 }; }
        function autoShoot() { if (!gameStarted || player.shootCooldown > 0) return; const speed = 12; const sel = playersData[selectedPlayerId] || playersData.default; const damage = sel.laserDamage || 1; const range = sel.laserRange || 300; const ox = player.x + player.size / 2; const oy = player.y + player.size / 2; lasers.push({ x: ox, y: oy, originX: ox, originY: oy, vx: shootDirection.x * speed, vy: shootDirection.y * speed, life: 60, damage: damage, range: range }); player.shootCooldown = 20; }
        if (shootBase) { shootBase.addEventListener('touchstart', function (e) { shootDragging = true; const rect = shootBase.getBoundingClientRect(); shootCenterX = rect.left + rect.width / 2; shootCenterY = rect.top + rect.height / 2; }); shootBase.addEventListener('touchmove', function (e) { if (shootDragging) { e.preventDefault(); updateShootStickPosition(e.touches[0].clientX, e.touches[0].clientY); } }); shootBase.addEventListener('touchend', function () { shootDragging = false; resetShootStick(); }); }

        gameCanvas.addEventListener('mousedown', function (e) { if (!gameStarted || player.shootCooldown > 0) return; const rect = gameCanvas.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top; const startX = player.x + player.size / 2; const startY = player.y + player.size / 2; const dx = mouseX - startX; const dy = mouseY - startY; const len = Math.sqrt(dx * dx + dy * dy) || 1; const speed = 12; const vx = dx / len * speed; const vy = dy / len * speed; const sel = playersData[selectedPlayerId] || playersData.default; const damage = sel.laserDamage || 1; const range = sel.laserRange || 300; lasers.push({ x: startX, y: startY, originX: startX, originY: startY, vx, vy, life: 60, damage: damage, range: range }); player.shootCooldown = 60; });

        function drawLasers() { ctx.save(); ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 4; lasers.forEach(function (l) { ctx.beginPath(); ctx.moveTo(l.x, l.y); ctx.lineTo(l.x - l.vx * 2, l.y - l.vy * 2); ctx.stroke(); }); ctx.restore(); }

        function updateLasers() {
            for (let i = lasers.length - 1; i >= 0; i--) {
                lasers[i].x += lasers[i].vx; lasers[i].y += lasers[i].vy; lasers[i].life--;
                let hitObstacle = false;
                for (let obs of obstacles) { if (checkCollisionWithRect({ x: lasers[i].x, y: lasers[i].y, size: 4 }, obs)) { hitObstacle = true; break; } }
                if (hitObstacle) { lasers.splice(i, 1); continue; }
                if (checkCollision(lasers[i], ai)) {
                    ai.hp -= (lasers[i].damage || 1);
                    lasers.splice(i, 1);
                    if (ai.hp <= 0) {
                        playerCoins += 100; playerLevel += 1; const reward = openLootBox(); if (reward.type === 'coins') playerCoins += reward.amount || 0; else if (reward.type === 'levels') playerLevel += reward.amount || 0; else if (reward.type === 'rank') playerLevel += 1; saveState(); showCoins(); showLootBoxResults(reward); setTimeout(function () { endGame(); }, 500); return;
                    }
                    continue;
                }
                // remove by range / life / out of bounds
                const ox = lasers[i].originX !== undefined ? lasers[i].originX : player.x + player.size/2;
                const oy = lasers[i].originY !== undefined ? lasers[i].originY : player.y + player.size/2;
                const range = lasers[i].range || 300;
                if (lasers[i].x < 0 || lasers[i].x > gameCanvas.width || lasers[i].y < 0 || lasers[i].y > gameCanvas.height || lasers[i].life <= 0 || getDistance(ox, oy, lasers[i].x, lasers[i].y) > range) { lasers.splice(i, 1); }
            }
        }

        function drawAILasers() { ctx.save(); ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 4; aiLasers.forEach(function (l) { ctx.beginPath(); ctx.moveTo(l.x, l.y); ctx.lineTo(l.x - l.vx * 2, l.y - l.vy * 2); ctx.stroke(); }); ctx.restore(); }

        function updateAILasers() {
            for (let i = aiLasers.length - 1; i >= 0; i--) {
                aiLasers[i].x += aiLasers[i].vx; aiLasers[i].y += aiLasers[i].vy; aiLasers[i].life--; let hitObstacle = false; for (let obs of obstacles) { if (checkCollisionWithRect({ x: aiLasers[i].x, y: aiLasers[i].y, size: 4 }, obs)) { hitObstacle = true; break; } } if (hitObstacle) { aiLasers.splice(i, 1); continue; } if (checkCollision(aiLasers[i], player)) { player.hp -= (aiLasers[i].damage || 1); aiLasers.splice(i, 1); if (player.hp <= 0) { alert('Game Over! You Lose!'); endGame(); } continue; } if (aiLasers[i].x < 0 || aiLasers[i].x > gameCanvas.width || aiLasers[i].y < 0 || aiLasers[i].y > gameCanvas.height || aiLasers[i].life <= 0 || getDistance(aiLasers[i].x, aiLasers[i].y, ai.x + ai.size / 2, ai.y + ai.size / 2) > 300) { aiLasers.splice(i, 1); } }
        }

        function getDistance(x1, y1, x2, y2) { return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)); }
        function checkCollision(laser, target) { return laser.x >= target.x && laser.x <= target.x + target.size && laser.y >= target.y && laser.y <= target.y + target.size; }
        function checkCollisionWithRect(rect1, rect2) { return rect1.x < rect2.x + rect2.width && rect1.x + (rect1.size || 0) > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + (rect1.size || 0) > rect2.y; }

        function drawObstacles() { ctx.save(); for (let obs of obstacles) { ctx.fillStyle = obs.type === 'lake' ? '#0077aa' : '#8B0000'; ctx.fillRect(obs.x, obs.y, obs.width, obs.height); } ctx.restore(); }

        // Add missing clearCanvas function so gameLoop can run without error
        function clearCanvas() { ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height); }

        function updateCooldowns() { if (player.shootCooldown > 0) player.shootCooldown--; if (ai.shootCooldown > 0) ai.shootCooldown--; }

        // unified per-frame input handling
        function handleInputFrame() {
            let inputX = 0, inputY = 0;
            if (keysPressed['arrowup'] || keysPressed['w']) inputY -= 1;
            if (keysPressed['arrowdown'] || keysPressed['s']) inputY += 1;
            if (keysPressed['arrowleft'] || keysPressed['a']) inputX -= 1;
            if (keysPressed['arrowright'] || keysPressed['d']) inputX += 1;
            // combine with touch movement
            let vx = inputX + (movement.x || 0);
            let vy = inputY + (movement.y || 0);
            const mag = Math.hypot(vx, vy);
            if (mag > 1) { vx /= mag; vy /= mag; }
            if (vx !== 0 || vy !== 0) {
                const oldX = player.x, oldY = player.y;
                player.x += vx * player.speed;
                player.y += vy * player.speed;

                // clamp to canvas
                player.x = Math.max(0, Math.min(player.x, gameCanvas.width - player.size));
                player.y = Math.max(0, Math.min(player.y, gameCanvas.height - player.size));

                for (let obs of obstacles) {
                    if (checkCollisionWithRect(player, obs)) {
                        // revert
                        player.x = oldX; player.y = oldY;
                        notifyObstacleHit();
                        break;
                    }
                }
            }
        }

        function gameLoop() {
            if (!loopStarted) { console.log('gameLoop started'); loopStarted = true; setDebug('running'); }
            clearCanvas();
            if (gameStarted) {
                handleInputFrame();
                drawObstacles(); drawPlayer(); drawAI(); drawHP(); updateAI(); updateCooldowns(); updateLasers(); drawLasers(); updateAILasers(); drawAILasers();
            }
            // update lastPlayerPos after AI uses previous frame's player movement
            lastPlayerPos.x = player.x;
            lastPlayerPos.y = player.y;
            requestAnimationFrame(gameLoop);
        }

        function startGame() { console.log('startGame called'); setDebug('start pressed'); document.getElementById('coins-display').style.display = 'block'; document.getElementById('skins-container').style.display = 'none'; document.getElementById('map-selection').style.display = 'none'; document.querySelector('.menu').style.display = 'none'; document.querySelector('.guide').style.display = 'none'; document.getElementById('rankings-container').style.display = 'none';
            // regenerate obstacles to fill the screen and ensure player/ai start in clear area
            generateObstacles();
            // choose free spawn positions and ensure they spawn farther apart
            const ppos = getSpawnPosition(player.size);
            player.x = ppos.x; player.y = ppos.y;
            // choose a much farther spawn for AI where possible
            let apos = getSpawnPosition(ai.size);
            // ensure AI spawns at least 500px away from player
            const desiredDistance = 500;
            let attempts = 0;
            while (getDistance(apos.x, apos.y, player.x, player.y) < desiredDistance && attempts < 200) {
                apos = getSpawnPosition(ai.size);
                attempts++;
            }
            ai.x = apos.x; ai.y = apos.y; ai.vx = ai.vy = 0; ai.pauseTimer = 0; ai.hp = 8;
            player.hp = (playersData[selectedPlayerId] || playersData.default).hp;
            lasers = []; aiLasers = []; ai.shootCooldown = 0; gameStarted = true; showCoins();
            // draw immediate frame so user sees the scene even if animation frame delayed
            clearCanvas(); drawObstacles(); drawPlayer(); drawAI(); drawHP();
            gameLoop(); }

        function endGame() { gameStarted = false; document.getElementById('coins-display').style.display = 'block'; document.querySelector('.menu').style.display = 'flex'; document.querySelector('.guide').style.display = 'block'; showCoins(); player.hp = (playersData[selectedPlayerId] || playersData.default).hp; ai.hp = 8; player.x = gameCanvas.width / 2; player.y = gameCanvas.height / 2; ai.x = gameCanvas.width / 4; ai.y = gameCanvas.height / 4; lasers = []; aiLasers = []; ai.shootCooldown = 0; }

        function openShop() { document.getElementById('skins-container').style.display = 'block'; loadSkins(); }

        const ladderRanks = [ { name: 'Bronze', min: 1, prize: 0 }, { name: 'Silver', min: 3, prize: 200 }, { name: 'Gold', min: 6, prize: 500 }, { name: 'Platinum', min: 10, prize: 1000 }, { name: 'Diamond', min: 15, prize: 2000 } ];
        function getCurrentRank(level) { let current = ladderRanks[0]; for (let i = 0; i < ladderRanks.length; i++) { if (level >= ladderRanks[i].min) current = ladderRanks[i]; } return current; }

        function showRankings() {
            const container = document.getElementById('rankings-container'); const list = document.getElementById('ladder-list'); const prizeMsg = document.getElementById('rank-prize-message'); const ownedDiv = document.getElementById('owned-players'); list.innerHTML = ''; prizeMsg.innerText = ''; ownedDiv.innerHTML = '';
            ownedDiv.innerHTML = '<strong>Owned Players:</strong> ' + unlockedPlayers.map(function (id) { return playersData[id] ? playersData[id].name : id; }).join(', ');
            let lastRank = localStorage.getItem('lastRank') || ladderRanks[0].name; let currentRank = getCurrentRank(playerLevel);
            ladderRanks.forEach(function (rank) { const li = document.createElement('li'); li.innerHTML = rank.name + ' (Level ' + rank.min + ')'; if (currentRank.name === rank.name) { li.style.color = '#ffcc00'; li.style.fontWeight = 'bold'; li.innerHTML += ' ← You are there!'; } list.appendChild(li); });
            if (currentRank.name !== lastRank) { if (currentRank.prize > 0) { playerCoins += currentRank.prize; saveState(); showCoins(); prizeMsg.innerText = 'Congratulations! You reached ' + currentRank.name + ' rank and won ' + currentRank.prize + ' coins!'; } else { prizeMsg.innerText = 'You reached ' + currentRank.name + ' rank!'; } localStorage.setItem('lastRank', currentRank.name); }
            container.style.display = 'block';
        }

        function closeRankings() { document.getElementById('rankings-container').style.display = 'none'; }

        // Attach UI button handlers
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('shop-btn').addEventListener('click', openShop);
        document.getElementById('rank-btn').addEventListener('click', showRankings);
        document.getElementById('close-rank-btn').addEventListener('click', closeRankings);
        document.getElementById('switch-player-btn').addEventListener('click', switchPlayer);

        function switchPlayer() {
            // cycle through unlocked players
            if (!Array.isArray(unlockedPlayers) || unlockedPlayers.length === 0) unlockedPlayers = ['default'];
            // ensure default present
            if (!unlockedPlayers.includes('default')) unlockedPlayers.unshift('default');
            const idx = Math.max(0, unlockedPlayers.indexOf(selectedPlayerId));
            const next = unlockedPlayers[(idx + 1) % unlockedPlayers.length];
            selectedPlayerId = next;
            updatePlayerFromSelection();
            alert('Switched to ' + (playersData[selectedPlayerId] || playersData.default).name);
        }

        // initial load
        updatePlayerFromSelection(); showCoins(); loadSkins(); loadMaps();

        } catch (err) {
            console.error('Initialization error:', err);
            setDebug('Init error: ' + (err && err.message));
            try { var disp = document.getElementById('coins-display'); if (disp) disp.innerText = 'Init error: ' + err.message; } catch (e) {}
            // removed blocking alert to avoid interruption during initialization errors
        }

    })();
    </script>
</body>
</html>