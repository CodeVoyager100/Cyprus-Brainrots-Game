<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>Cyprus Brainrot Game</title>
    <style>
        /* Your existing CSS styles remain the same */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
        }

        .guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            max-width: 400px;
            text-align: center;
            border: 2px solid #ffcc00;
        }

        #coins-display {
            font-size: 18px;
            color: gold;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 8px;
        }

        .skin-card {
            display: inline-block;
            background-color: #f4f4f4;
            border: 2px solid #ccc;
            padding: 10px;
            margin: 10px;
            text-align: center;
            border-radius: 12px;
            width: 180px;
            color: #000;
        }

            .skin-card h3,
            .skin-card p {
                color: #000;
                margin: 6px 0;
            }

        .skin-img {
            width: 100%;
            border-radius: 10px;
            height: 120px;
            object-fit: cover;
        }

        .menu {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 10px;
        }

        .btn {
            background-color: #444;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

            .btn:hover {
                background-color: #666;
                transform: scale(1.05);
            }

            .btn:disabled {
                background-color: #777;
                cursor: not-allowed;
                transform: none;
            }

        .modal-panel {
            display: none;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            color: #fff;
            padding: 20px;
            border-radius: 12px;
            z-index: 1000;
            max-width: 90vw;
            width: 800px;
            max-height: 80vh;
            overflow: auto;
            border: 2px solid #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.3);
        }

            .modal-panel h2 {
                margin-top: 0;
                color: #ffcc00;
                text-align: center;
                font-size: 24px;
            }

        .modal-close {
            display: block;
            margin: 15px auto 0;
            background: #ff4444;
        }

            .modal-close:hover {
                background: #ff6666;
            }

        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #joystick-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 9999;
        }

        #joystick-base {
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
            border: 2px solid rgba(255,255,255,0.5);
        }

        #joystick-stick {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            left: 25px;
            top: 25px;
            touch-action: none;
            transition: transform 0.1s;
        }

        #shoot-joystick-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 9999;
        }

        #shoot-joystick-base {
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
            border: 2px solid rgba(255,100,100,0.5);
        }

        #shoot-joystick-stick {
            width: 50px;
            height: 50px;
            background: rgba(255, 100, 100, 0.8);
            border-radius: 50%;
            position: absolute;
            left: 25px;
            top: 25px;
            touch-action: none;
            transition: transform 0.1s;
        }

        /* Add this to your existing CSS */
        @media (max-width: 1024px) {
            #joystick-container, #shoot-joystick-container {
                display: block !important;
            }
        }

        @media (min-width: 1025px) {
            #joystick-container, #shoot-joystick-container {
                display: none !important;
            }
        }
        #debug-status {
            position: fixed;
            right: 10px;
            top: 50px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            padding: 8px 10px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 6px;
            z-index: 99999;
            max-width: 300px;
            pointer-events: none;
        }

        #lootbox-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #FFD700, #FFAA00);
            padding: 30px;
            border-radius: 20px;
            border: 5px solid white;
            z-index: 1000;
            text-align: center;
            box-shadow: 0 0 30px rgba(255,215,0,0.7);
        }

        .game-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 999;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            text-align: center;
        }

        .health-pack {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }
    </style>
</head>
<body>
    <div class="guide">
        <h2 style="color: #ffcc00; margin-top: 0;">Welcome to Cyprus Brainrot Game!</h2>
        <p>
            🎮 Use arrow keys or WASD to move<br>
            🖱️ Click mouse to shoot<br>
            ⚔️ Click "Battle!" to start a game<br>
            🛒 Collect coins and unlock players in the Bazaar!<br>
            ❤️ Collect green health packs to heal!<br>
            🔁 Switch players between matches
        </p>
        <p style="color: #ffcc00; font-weight: bold;">Good luck and have fun! 🎯</p>
    </div>

    <div id="lootbox-popup">
        <h2 style="color:#FFF; text-shadow:2px 2px 4px #000;">LOOT BOX REWARD!</h2>
        <div id="lootbox-content" style="font-size:24px; margin:20px 0;"></div>
        <button id="lootbox-ok" style="background:#FFF; border:none; padding:10px 20px; border-radius:10px; font-weight:bold;">OK</button>
    </div>

    <div id="game-over-overlay" class="game-overlay">
        <div style="background: rgba(0,0,0,0.9); padding: 40px; border-radius: 20px; border: 3px solid #ffcc00;">
            <h2 id="game-over-title" style="color: #ffcc00;">Game Over</h2>
            <p id="game-over-message" style="margin: 20px 0;"></p>
            <button id="return-to-menu" class="btn" style="background: #ffcc00; color: black; font-size: 18px; padding: 10px 20px;">
                Return to Menu
            </button>
        </div>
    </div>

    <div id="coins-display">💰 Coins: 500<br>🏆 Level: 1</div>

    <div id="skins-container" class="modal-panel">
        <h2>🛒 Bazaar</h2>
        <div id="bazaar-items" style="display:flex; flex-wrap:wrap; gap:10px; justify-content:center;"></div>
        <button class="btn modal-close" id="close-bazaar">Close</button>
    </div>

    <div id="player-menu" class="modal-panel">
        <h2>Players</h2>
        <div id="player-list" style="display:flex; flex-wrap:wrap; gap:10px; justify-content:center;"></div>
        <button class="btn modal-close" id="close-player-menu">Close</button>
    </div>

    <div id="game-modes-container" class="modal-panel">
        <h2>🎮 Select Game Mode</h2>
        <div class="game-modes-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
            <div class="mode-card" data-mode="showdown">
                <h3>👑 Showdown</h3>
                <p>Battle Royale - Last player standing wins!</p>
                <div style="background: rgba(255, 204, 0, 0.2); padding: 5px 10px; border-radius: 20px; font-size: 12px; font-weight: bold;">1-4 Players</div>
            </div>
            <div class="mode-card" data-mode="3v3">
                <h3>⚔️ 3v3 Team Battle</h3>
                <p>Team up and defeat the enemy team!</p>
                <div style="background: rgba(255, 204, 0, 0.2); padding: 5px 10px; border-radius: 20px; font-size: 12px; font-weight: bold;">4 Players</div>
            </div>
        </div>
        <button class="btn modal-close" id="close-modes-btn">Close</button>
    </div>

    <div class="menu">
        <button class="btn" id="game-mode-btn">🎮 Game Modes</button>
        <button class="btn" id="start-btn">⚔️ Battle!</button>
        <button class="btn" id="shop-btn">🛒 Bazaar</button>
        <button class="btn" id="switch-player-btn">🔁 Switch Player</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>

    <div id="shoot-joystick-container">
        <div id="shoot-joystick-base">
            <div id="shoot-joystick-stick"></div>
        </div>
    </div>

    <div id="debug-status">Loading...</div>

    <script>
        // Game initialization
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = gameCanvas.getContext('2d');

        // Game variables
        let obstacles = [];
        let gameStarted = false;
        let lasers = [];
        let aiLasers = [];
        let healthPacks = [];
        let players = [];
        let bots = [];
        let player = null;

        // Camera system
        let camera = { x: 0, y: 0, width: 0, height: 0 };
        const MAP_WIDTH = 2000;
        const MAP_HEIGHT = 2000;

        // Game state
        let playerCoins = 500;
        let unlockedPlayers = ['default'];
        let selectedPlayerId = 'default';
        let playerLevel = 1;
        let currentGameMode = 'showdown';

        // Image cache for all game images
        const imageCache = {};

        function loadImage(src) {
            if (!imageCache[src]) {
                imageCache[src] = new Image();
                imageCache[src].src = src;
                imageCache[src].onerror = function () {
                    console.warn('Failed to load image:', src);
                    // Create a colored fallback
                    const canvas = document.createElement('canvas');
                    canvas.width = 100;
                    canvas.height = 100;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillRect(0, 0, 100, 100);
                    ctx.fillStyle = '#000';
                    ctx.font = '12px Arial';
                    ctx.fillText('No Image', 10, 50);
                    imageCache[src].src = canvas.toDataURL();
                };
            }
            return imageCache[src];
        }

        // Preload all images when game starts
        function preloadImages() {
            console.log('Preloading images...');

            // Preload background
            loadImage('images/background.png');

            // Preload player images
            Object.values(playersData).forEach(player => {
                if (player.img) {
                    loadImage(player.img);
                }
            });
        }

        const playersData = {
            default: {
                id: 'default',
                name: 'soublakiscorpio',
                img: 'images/ScorpiosSouvlak.png',
                color: '#4a86e8',
                hp: 20,
                speed: 4,
                laserDamage: 1,
                size: 55,
                laserRange: 250,
                price: 0
            },
            tornader: {
                id: 'tornader',
                name: 'Tornader',
                img: 'images/rot2.png',
                color: '#e84a4a',
                hp: 32,
                speed: 5,
                laserDamage: 3,
                size: 55,
                laserRange: 300,
                price: 1200
            },
            lazerman: {
                id: 'lazerman',
                name: 'Lazerman',
                img: 'images/rot1.png',
                color: '#4ae84a',
                hp: 37,
                speed: 4,
                laserDamage: 2,
                size: 55,
                laserRange: 800,
                price: 500
            },
            fournakis: {
                id: 'fournakis',
                name: 'Fournakis',
                img: 'images/pkiotisfournos.png',
                color: '#e8e84a',
                hp: 32,
                speed: 5,
                laserDamage: 2,
                size: 55,
                laserRange: 400,
                price: 700
            },
            kleftikomegazord: {
                id: 'kleftikomegazord',
                name: 'Kleftikomegazord',
                img: 'images/rot3.png',
                color: '#e8e84a',
                hp: 70,
                speed: 3,
                laserDamage: 6,
                size: 65,
                laserRange: 600,
                price: 2000
            },
            baklavasbazookos: {
                id: 'baklavasbazookos',
                name: 'Baklavasbazookos',
                img: 'images/baklavasbazooka.png',
                color: '#e8e84a',
                hp: 40,
                speed: 5,
                laserDamage: 3,
                size: 55,
                laserRange: 500,
                price: 700
            },
            firekoupepy: {
                id: 'firekoupepy',
                name: 'Firekoupepy',
                img: 'images/firekoupepiy.png',
                color: '#e8e84a',
                hp: 40,
                speed: 5,
                laserDamage: 3,
                size: 55,
                laserRange: 450,
                price: 500
            },
            boboshiros: {
                id: 'boboshiros',
                name: 'Boboshiros',
                img: 'images/boboshiros.png',
                color: '#e8e84a',
                hp: 45,
                speed: 5,
                laserDamage: 4,
                size: 55,
                laserRange: 550,
                price: 700
            },
            megagrinos: {
                id: 'megagrinos',
                name: 'Megagrinos',
                img: 'images/megagrinos.png',
                color: '#e8e84a',
                hp: 50,
                speed: 4,
                laserDamage: 4,
                size: 60,
                laserRange: 550,
                price: 1000
            },
            kafekauboy: {
                id: 'kafekauboy',
                name: 'Kafekauboy',
                img: 'images/kafechinocauboyno.png',
                color: '#e8e84a',
                hp: 45,
                speed: 5,
                laserDamage: 4,
                size: 55,
                laserRange: 550,
                price: 800
            }
        };

        const gameModes = {
            showdown: { name: "Showdown", maxPlayers: 4, teams: false, fillBots: true },
            '3v3': { name: "3v3 Team Battle", maxPlayers: 4, teams: true, teamSize: 2, fillBots: true }
        };

        // Input handling
        const keysPressed = {};
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            keysPressed[k] = true;
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            keysPressed[k] = false;
        });

        // Core game functions
        function resizeCanvas() {
            gameCanvas.width = window.innerWidth;
            gameCanvas.height = window.innerHeight;
            camera.width = window.innerWidth;
            camera.height = window.innerHeight;
        }

        // ADD MISSING CAMERA FUNCTION
        function updateCamera() {
            if (!player) return;

            // Center camera on player
            camera.x = player.x + player.size / 2 - camera.width / 2;
            camera.y = player.y + player.size / 2 - camera.height / 2;

            // Keep camera within map bounds
            camera.x = Math.max(0, Math.min(camera.x, MAP_WIDTH - camera.width));
            camera.y = Math.max(0, Math.min(camera.y, MAP_HEIGHT - camera.height));
        }

        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function checkCollisionWithRect(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.size > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.size > rect2.y;
        }

        // NEW: Check if a position is valid (not inside obstacles)
        function isValidSpawnPosition(x, y, size) {
            for (let obs of obstacles) {
                if (x < obs.x + obs.width &&
                    x + size > obs.x &&
                    y < obs.y + obs.height &&
                    y + size > obs.y) {
                    return false;
                }
            }
            return true;
        }

        function getSpawnPosition(size) {
            const padding = 100;
            let attempts = 0;
            let pos;

            // Keep trying until we find a valid position not inside obstacles
            do {
                pos = {
                    x: padding + Math.random() * (MAP_WIDTH - padding * 2 - size),
                    y: padding + Math.random() * (MAP_HEIGHT - padding * 2 - size)
                };
                attempts++;
            } while (!isValidSpawnPosition(pos.x, pos.y, size) && attempts < 50);

            return pos;
        }

        function generateObstacles() {
            obstacles = [];
            for (let i = 0; i < 15; i++) {
                obstacles.push({
                    x: Math.random() * (MAP_WIDTH - 100),
                    y: Math.random() * (MAP_HEIGHT - 100),
                    width: 60 + Math.random() * 60,
                    height: 60 + Math.random() * 60,
                    type: Math.random() < 0.5 ? 'brick' : 'water'
                });
            }
        }

        function generateHealthPacks() {
            healthPacks = [];
            for (let i = 0; i < 8; i++) {
                const pos = getSpawnPosition(30);
                healthPacks.push({
                    x: pos.x,
                    y: pos.y,
                    size: 30,
                    healAmount: 10,
                    active: true
                });
            }
        }

        // NEW: Check laser collision with obstacles
        function checkLaserObstacleCollision(laser) {
            for (let obs of obstacles) {
                // Only check collision with brown bricks (not water)
                if (obs.type === 'brick') {
                    // Simple line-rectangle collision detection
                    const laserStartX = laser.x;
                    const laserStartY = laser.y;
                    const laserEndX = laser.x + laser.vx;
                    const laserEndY = laser.y + laser.vy;

                    // Check if laser line intersects with obstacle rectangle
                    if (lineIntersectsRect(laserStartX, laserStartY, laserEndX, laserEndY, obs)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // NEW: Line-rectangle intersection detection
        function lineIntersectsRect(x1, y1, x2, y2, rect) {
            // Check if either end is inside the rectangle
            if ((x1 >= rect.x && x1 <= rect.x + rect.width && y1 >= rect.y && y1 <= rect.y + rect.height) ||
                (x2 >= rect.x && x2 <= rect.x + rect.width && y2 >= rect.y && y2 <= rect.y + rect.height)) {
                return true;
            }

            // Check line intersections with rectangle edges
            const left = lineIntersectsLine(x1, y1, x2, y2, rect.x, rect.y, rect.x, rect.y + rect.height);
            const right = lineIntersectsLine(x1, y1, x2, y2, rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height);
            const top = lineIntersectsLine(x1, y1, x2, y2, rect.x, rect.y, rect.x + rect.width, rect.y);
            const bottom = lineIntersectsLine(x1, y1, x2, y2, rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height);

            return left || right || top || bottom;
        }

        // NEW: Line-line intersection detection
        function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
            if (denominator === 0) return false;

            const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
            const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

            return (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1);
        }

        // Health pack collision
        // SIMPLIFIED Health pack collision - no cooldown for now
        function checkHealthPackCollision(entity) {
            if (!entity) return;

            for (let i = healthPacks.length - 1; i >= 0; i--) {
                const pack = healthPacks[i];
                if (!pack || !pack.active) continue;

                // Simple rectangle collision
                if (entity.x < pack.x + pack.size &&
                    entity.x + entity.size > pack.x &&
                    entity.y < pack.y + pack.size &&
                    entity.y + entity.size > pack.y) {

                    console.log("Health pack collision detected!");
                    console.log("Before healing - HP:", entity.currentHp, "Max HP:", entity.maxHp);

                    const healAmount = 10;

                    // Only heal if not at full health
                    if (entity.currentHp < entity.maxHp) {
                        // Heal the entity
                        entity.currentHp = Math.min(entity.maxHp, entity.currentHp + healAmount);
                        entity.hp = entity.currentHp; // Keep them synchronized

                        console.log("After healing - HP:", entity.currentHp);

                        // Remove the health pack
                        healthPacks.splice(i, 1);

                        // Respawn health pack after 10 seconds
                        setTimeout(() => {
                            const newPos = getSpawnPosition(30);
                            healthPacks.push({
                                x: newPos.x,
                                y: newPos.y,
                                size: 30,
                                healAmount: 10,
                                active: true
                            });
                            console.log("Health pack respawned");
                        }, 10000);

                        if (entity.isHuman) {
                            setDebug(`Healed +${healAmount} HP! Current: ${entity.currentHp}`);
                        }
                    } else {
                        console.log("Already at full health, no healing needed");
                    }
                    break;
                }
            }
        }

        // Player movement and shooting
        function handleInputFrame() {
            if (!player) return;

            let inputX = 0, inputY = 0;
            if (keysPressed['arrowup'] || keysPressed['w']) inputY -= 1;
            if (keysPressed['arrowdown'] || keysPressed['s']) inputY += 1;
            if (keysPressed['arrowleft'] || keysPressed['a']) inputX -= 1;
            if (keysPressed['arrowright'] || keysPressed['d']) inputX += 1;

            if (inputX !== 0 && inputY !== 0) {
                inputX *= 0.707;
                inputY *= 0.707;
            }

            if (inputX !== 0 || inputY !== 0) {
                const oldX = player.x, oldY = player.y;
                player.x += inputX * player.speed;
                player.y += inputY * player.speed;

                player.x = Math.max(0, Math.min(player.x, MAP_WIDTH - player.size));
                player.y = Math.max(0, Math.min(player.y, MAP_HEIGHT - player.size));

                for (let obs of obstacles) {
                    if (checkCollisionWithRect(player, obs)) {
                        player.x = oldX;
                        player.y = oldY;
                        break;
                    }
                }
            }

            // Check for health pack collision
            checkHealthPackCollision(player);

            if (player.shootCooldown > 0) player.shootCooldown--;
        }

        function playerShoot(targetX, targetY) {
            if (!player || player.shootCooldown > 0) return;

            const startX = player.x + player.size / 2;
            const startY = player.y + player.size / 2;
            const dx = targetX - startX;
            const dy = targetY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance === 0) return;

            const speed = 12;
            lasers.push({
                x: startX,
                y: startY,
                vx: (dx / distance) * speed,
                vy: (dy / distance) * speed,
                life: 90,
                damage: player.laserDamage,
                shooter: player // Track who shot this laser
            });

            player.shootCooldown = 15;
        }

        // IMPROVED AI SYSTEM - Bots fight each other and don't always chase player
        function updateAllBots() {
            bots.forEach(bot => {
                if (bot.hp <= 0) return;

                // Find closest target (could be player OR another bot in showdown mode)
                let closestTarget = findClosestTarget(bot);

                // Check for health packs when low health
                if (bot.hp < bot.maxHp * 0.6) {
                    const nearestHealthPack = findNearestHealthPack(bot);
                    if (nearestHealthPack && getDistance(bot.x, bot.y, nearestHealthPack.x, nearestHealthPack.y) < 400) {
                        // Move toward health pack
                        const dx = nearestHealthPack.x - bot.x;
                        const dy = nearestHealthPack.y - bot.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > 15) {
                            bot.vx = (dx / distance) * bot.speed;
                            bot.vy = (dy / distance) * bot.speed;
                        }
                        checkHealthPackCollision(bot);
                        return;
                    }
                }

                // If no target, wander
                if (!closestTarget) {
                    wanderBehavior(bot);
                    return;
                }

                const dx = closestTarget.x - bot.x;
                const dy = closestTarget.y - bot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // IMPROVED: Don't always chase - sometimes strafe or maintain distance
                if (distance > 0) {
                    // 30% chance to strafe instead of direct chase
                    if (Math.random() < 0.3 && distance < bot.laserRange * 0.8) {
                        // Strafe around target
                        const strafeAngle = Math.atan2(dy, dx) + (Math.PI / 2);
                        const strafeDir = Math.random() < 0.5 ? 1 : -1;
                        bot.vx = Math.cos(strafeAngle) * bot.speed * 0.7 * strafeDir;
                        bot.vy = Math.sin(strafeAngle) * bot.speed * 0.7 * strafeDir;
                    } else {
                        // Move toward target but maintain optimal distance
                        const optimalDistance = bot.laserRange * 0.6;
                        const moveDistance = Math.max(0, distance - optimalDistance);

                        if (moveDistance > 20) {
                            bot.vx = (dx / distance) * bot.speed * 0.8;
                            bot.vy = (dy / distance) * bot.speed * 0.8;
                        } else if (distance < optimalDistance - 20) {
                            // Back away if too close
                            bot.vx = (-dx / distance) * bot.speed * 0.6;
                            bot.vy = (-dy / distance) * bot.speed * 0.6;
                        } else {
                            // Small random movements when at optimal distance
                            bot.vx = (Math.random() - 0.5) * bot.speed * 0.3;
                            bot.vy = (Math.random() - 0.5) * bot.speed * 0.3;
                        }
                    }
                }

                // Shooting - only shoot if target is in range and has line of sight
                if (bot.shootCooldown <= 0 && distance < bot.laserRange &&
                    hasLineOfSight(bot, closestTarget) && Math.random() < 0.03) {

                    const aimDx = closestTarget.x - (bot.x + bot.size / 2);
                    const aimDy = closestTarget.y - (bot.y + bot.size / 2);
                    const aimDist = Math.sqrt(aimDx * aimDx + aimDy * aimDy);

                    if (aimDist > 0) {
                        aiLasers.push({
                            x: bot.x + bot.size / 2,
                            y: bot.y + bot.size / 2,
                            vx: (aimDx / aimDist) * 10,
                            vy: (aimDy / aimDist) * 10,
                            life: 90,
                            damage: bot.laserDamage,
                            shooter: bot // Track who shot this laser
                        });
                        bot.shootCooldown = 30;
                    }
                }

                if (bot.shootCooldown > 0) bot.shootCooldown--;

                // Apply movement
                const oldX = bot.x, oldY = bot.y;
                bot.x += bot.vx;
                bot.y += bot.vy;

                bot.x = Math.max(0, Math.min(bot.x, MAP_WIDTH - bot.size));
                bot.y = Math.max(0, Math.min(bot.y, MAP_HEIGHT - bot.size));

                for (let obs of obstacles) {
                    if (checkCollisionWithRect(bot, obs)) {
                        bot.x = oldX;
                        bot.y = oldY;
                        break;
                    }
                }
            });
        }

        // NEW: Find closest target (player OR other bots in showdown)
        function findClosestTarget(bot) {
            let closest = null;
            let minDistance = Infinity;

            players.forEach(other => {
                if (other === bot || other.currentHp <= 0) return;

                // In team modes, don't target teammates
                if (bot.team && other.team === bot.team) return;

                const dist = getDistance(bot.x, bot.y, other.x, other.y);

                // Prefer closer targets, but add some randomness so they don't always target the same
                const weightedDistance = dist * (0.8 + Math.random() * 0.4);

                if (weightedDistance < minDistance && weightedDistance < 600) {
                    minDistance = weightedDistance;
                    closest = other;
                }
            });

            return closest;
        }

        // NEW: Check line of sight for shooting (now considers obstacles)
        function hasLineOfSight(shooter, target) {
            const distance = getDistance(shooter.x, shooter.y, target.x, target.y);
            if (distance > shooter.laserRange) return false;

            // Check if there are any brown brick obstacles between shooter and target
            for (let obs of obstacles) {
                if (obs.type === 'brick') {
                    // Simple line of sight check using line-rectangle intersection
                    if (lineIntersectsRect(
                        shooter.x + shooter.size / 2, shooter.y + shooter.size / 2,
                        target.x + target.size / 2, target.y + target.size / 2,
                        obs
                    )) {
                        return false;
                    }
                }
            }
            return true;
        }

        // NEW: Improved wandering behavior
        function wanderBehavior(bot) {
            if (!bot.wanderTarget || getDistance(bot.x, bot.y, bot.wanderTarget.x, bot.wanderTarget.y) < 30) {
                // Set new wander target
                bot.wanderTarget = getSpawnPosition(10);
                bot.wanderTimer = 60 + Math.floor(Math.random() * 60);
            }

            const dx = bot.wanderTarget.x - bot.x;
            const dy = bot.wanderTarget.y - bot.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 20) {
                bot.vx = (dx / distance) * bot.speed * 0.5;
                bot.vy = (dy / distance) * bot.speed * 0.5;
            } else {
                bot.vx = (Math.random() - 0.5) * bot.speed * 0.3;
                bot.vy = (Math.random() - 0.5) * bot.speed * 0.3;
            }
        }

        function findNearestHealthPack(bot) {
            let nearest = null;
            let minDistance = Infinity;

            for (let pack of healthPacks) {
                if (!pack.active) continue;
                const dist = getDistance(bot.x, bot.y, pack.x, pack.y);
                if (dist < minDistance) {
                    minDistance = dist;
                    nearest = pack;
                }
            }
            return nearest;
        }

        // Game setup
        // Game setup
        function setupGameMode(mode) {
            const modeConfig = gameModes[mode];
            players = [];
            bots = [];
            lasers = [];
            aiLasers = [];

            generateObstacles();
           // generateHealthPacks();

            // Create player
            const playerData = playersData[selectedPlayerId];
            const playerPos = getSpawnPosition(playerData.size);
            player = {
                ...playerData,
                x: playerPos.x,
                y: playerPos.y,
                isHuman: true,
                team: modeConfig.teams ? 'red' : null,
                hp: playerData.hp,
                maxHp: playerData.hp,
                currentHp: playerData.hp,
                shootCooldown: 0,
                healCooldown: 0 // Initialize heal cooldown
            };
            players.push(player);

            // Create bots
            const botCount = modeConfig.maxPlayers - 1;
            for (let i = 0; i < botCount; i++) {
                const availableBots = Object.keys(playersData).filter(id => id !== selectedPlayerId);
                const botPlayerId = availableBots[Math.floor(Math.random() * availableBots.length)];
                const botData = playersData[botPlayerId];
                const botPos = getSpawnPosition(botData.size);

                const bot = {
                    ...botData,
                    id: `bot_${i}`,
                    x: botPos.x,
                    y: botPos.y,
                    isBot: true,
                    team: modeConfig.teams ? (i < Math.floor(botCount / 2) ? 'blue' : 'red') : null,
                    hp: botData.hp,
                    maxHp: botData.hp,
                    currentHp: botData.hp,
                    vx: 0,
                    vy: 0,
                    shootCooldown: 0,
                    healCooldown: 0, // Initialize heal cooldown
                    wanderTarget: null,
                    wanderTimer: 0
                };
                players.push(bot);
                bots.push(bot);
            }

            console.log(`Game setup complete: ${modeConfig.name} with ${players.length} players`);
        }

        // Drawing functions
        function drawBackground() {
            // Try to draw background image
            const bgImage = imageCache['images/background.png'];
            if (bgImage && bgImage.complete) {
                // Create pattern for tiling
                const pattern = ctx.createPattern(bgImage, 'repeat');
                ctx.fillStyle = pattern;
                ctx.fillRect(0 - camera.x, 0 - camera.y, MAP_WIDTH, MAP_HEIGHT);
            } else {
                // Fallback to gradient background
                const gradient = ctx.createLinearGradient(0, 0, MAP_WIDTH, MAP_HEIGHT);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#16213e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0 - camera.x, 0 - camera.y, MAP_WIDTH, MAP_HEIGHT);
            }
        }

        function drawObstacles() {
            ctx.save();
            for (let obs of obstacles) {
                if (obs.type === 'water') {
                    ctx.fillStyle = '#0077aa';
                    ctx.fillRect(obs.x - camera.x, obs.y - camera.y, obs.width, obs.height);

                    // Water effect
                    ctx.strokeStyle = '#00aaff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obs.x - camera.x, obs.y - camera.y, obs.width, obs.height);
                } else {
                    // Brick pattern
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(obs.x - camera.x, obs.y - camera.y, obs.width, obs.height);

                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < obs.width; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(obs.x - camera.x + i, obs.y - camera.y);
                        ctx.lineTo(obs.x - camera.x + i, obs.y - camera.y + obs.height);
                        ctx.stroke();
                    }
                    for (let i = 0; i < obs.height; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(obs.x - camera.x, obs.y - camera.y + i);
                        ctx.lineTo(obs.x - camera.x + obs.width, obs.y - camera.y + i);
                        ctx.stroke();
                    }
                }
            }
            ctx.restore();
        }

     /*   function drawHealthPacks() {
            ctx.save();
            for (let pack of healthPacks) {
                if (!pack.active) continue;

                // Pulsating effect
                const pulse = Math.sin(Date.now() / 200) * 3 + 1;
                const pulseSize = 30 * pulse;

                ctx.fillStyle = '#00ff00';
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = 15;

                // Draw cross shape with pulse effect
                const centerX = pack.x - camera.x + 15;
                const centerY = pack.y - camera.y + 15;

                ctx.fillRect(centerX - 5, centerY - 15, 10, 30);
                ctx.fillRect(centerX - 15, centerY - 5, 30, 10);

                // Draw healing symbol
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('+', centerX, centerY);

                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }
        */
        // Debug function to test health pack collection
        function testHealthPack() {
            if (!player) return;

            console.log("Testing health pack collection...");
            console.log("Player HP before:", player.currentHp);

            // Create a health pack right on the player
            healthPacks.push({
                x: player.x,
                y: player.y,
                size: 30,
                healAmount: 10,
                active: true
            });

            console.log("Health pack created at player position");
        }

        // Call this from console: testHealthPack()
       // window.testHealthPack = testHealthPack;
        function drawPlayers() {
            players.forEach(p => {
                if (p.currentHp <= 0) return;

                ctx.save();

                // Try to draw player image if available
                if (p.img && imageCache[p.img] && imageCache[p.img].complete) {
                    ctx.drawImage(
                        imageCache[p.img],
                        p.x - camera.x,
                        p.y - camera.y,
                        p.size,
                        p.size
                    );

                    // Add glow effect for human player
                    if (p.isHuman) {
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 15;
                        ctx.drawImage(
                            imageCache[p.img],
                            p.x - camera.x,
                            p.y - camera.y,
                            p.size,
                            p.size
                        );
                        ctx.shadowBlur = 0;
                    }
                } else {
                    // Fallback to colored rectangle
                    ctx.fillStyle = p.color;
                    if (p.isHuman) {
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 15;
                    }
                    ctx.fillRect(p.x - camera.x, p.y - camera.y, p.size, p.size);
                    ctx.shadowBlur = 0;
                }

                // HP bar background
                ctx.fillStyle = '#333';
                ctx.fillRect(p.x - camera.x, p.y - camera.y - 12, p.size, 6);

                // HP bar - use currentHp instead of hp
                const hpPercent = p.currentHp / p.maxHp;
                ctx.fillStyle = hpPercent > 0.6 ? '#00ff00' : hpPercent > 0.3 ? '#ffff00' : '#ff0000';
                ctx.fillRect(p.x - camera.x, p.y - camera.y - 12, p.size * hpPercent, 6);

                // Name tag
                if (p.isHuman) {
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.name, p.x - camera.x + p.size / 2, p.y - camera.y - 20);
                }

                ctx.restore();
            });
        }

        function drawLasers() {
            ctx.save();
            lasers.forEach(laser => {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.moveTo(laser.x - camera.x, laser.y - camera.y);
                ctx.lineTo(laser.x - camera.x - laser.vx * 2, laser.y - camera.y - laser.vy * 2);
                ctx.stroke();
            });

            aiLasers.forEach(laser => {
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ff4444';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.moveTo(laser.x - camera.x, laser.y - camera.y);
                ctx.lineTo(laser.x - camera.x - laser.vx * 2, laser.y - camera.y - laser.vy * 2);
                ctx.stroke();
            });
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function drawHUD() {
            if (!player) return;
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(10, 10, 200, 80);

            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.fillText(`HP: ${player.currentHp}/${player.maxHp}`, 20, 30);
            ctx.fillText(`Mode: ${gameModes[currentGameMode].name}`, 20, 50);
            ctx.fillText(`Players: ${players.filter(p => p.currentHp > 0).length}/${players.length}`, 20, 70);
            ctx.restore();
        }

        // FIXED LASER COLLISION SYSTEM - AI lasers can damage other AI players AND check obstacle collisions
        function updateLasers() {
            // Update player lasers
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                laser.x += laser.vx;
                laser.y += laser.vy;
                laser.life--;

                // Check collision with brown brick obstacles
                if (checkLaserObstacleCollision(laser)) {
                    lasers.splice(i, 1);
                    continue;
                }

                // Check collisions with all players (except the shooter)
                let hit = false;
                for (let j = 0; j < players.length; j++) {
                    const targetPlayer = players[j];
                    // Don't hit the shooter
                    if (targetPlayer === laser.shooter) continue;

                    if (laser.x >= targetPlayer.x && laser.x <= targetPlayer.x + targetPlayer.size &&
                        laser.y >= targetPlayer.y && laser.y <= targetPlayer.y + targetPlayer.size) {

                        // Use currentHp for damage calculation
                        targetPlayer.currentHp -= laser.damage;
                        hit = true;

                        if (targetPlayer.currentHp <= 0) {
                            players.splice(j, 1);
                            if (targetPlayer.isBot) {
                                const botIndex = bots.findIndex(b => b.id === targetPlayer.id);
                                if (botIndex !== -1) bots.splice(botIndex, 1);
                            }
                        }
                        break;
                    }
                }

                if (hit || laser.life <= 0) {
                    lasers.splice(i, 1);
                }
            }

            // Update AI lasers - can hit ANY player (including other bots)
            for (let i = aiLasers.length - 1; i >= 0; i--) {
                const laser = aiLasers[i];
                laser.x += laser.vx;
                laser.y += laser.vy;
                laser.life--;

                // Check collision with brown brick obstacles
                if (checkLaserObstacleCollision(laser)) {
                    aiLasers.splice(i, 1);
                    continue;
                }

                // Check collisions with all players (except the shooter)
                let hit = false;
                for (let j = 0; j < players.length; j++) {
                    const targetPlayer = players[j];
                    // Don't hit the shooter
                    if (targetPlayer === laser.shooter) continue;

                    if (laser.x >= targetPlayer.x && laser.x <= targetPlayer.x + targetPlayer.size &&
                        laser.y >= targetPlayer.y && laser.y <= targetPlayer.y + targetPlayer.size) {

                        // Use currentHp for damage calculation
                        targetPlayer.currentHp -= laser.damage;
                        hit = true;

                        if (targetPlayer.currentHp <= 0) {
                            players.splice(j, 1);
                            if (targetPlayer.isBot) {
                                const botIndex = bots.findIndex(b => b.id === targetPlayer.id);
                                if (botIndex !== -1) bots.splice(botIndex, 1);
                            }

                            // Check if player died
                            if (targetPlayer.isHuman) {
                                endGame('Game Over! You were defeated!', false);
                            }
                        }
                        break;
                    }
                }

                if (hit || laser.life <= 0) {
                    aiLasers.splice(i, 1);
                }
            }
        }
        /*********************************************************************/
        //start joystick implementation
        //******************************************************************* */
        // Joystick Variables
        let moveJoystickActive = false;
        let shootJoystickActive = false;
        let moveJoystick = { x: 0, y: 0, magnitude: 0 };
        let shootJoystick = { x: 0, y: 0, magnitude: 0 };

        // Initialize Joysticks
        function initJoysticks() {
            const moveBase = document.getElementById('joystick-base');
            const moveStick = document.getElementById('joystick-stick');
            const shootBase = document.getElementById('shoot-joystick-base');
            const shootStick = document.getElementById('shoot-joystick-stick');

            // Movement Joystick
            moveBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                moveJoystickActive = true;
                updateMoveJoystick(e);
            });

            moveBase.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (moveJoystickActive) {
                    updateMoveJoystick(e);
                }
            });

            moveBase.addEventListener('touchend', (e) => {
                e.preventDefault();
                moveJoystickActive = false;
                resetMoveJoystick();
            });

            // Shooting Joystick
            shootBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                shootJoystickActive = true;
                updateShootJoystick(e);
            });

            shootBase.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (shootJoystickActive) {
                    updateShootJoystick(e);
                }
            });

            shootBase.addEventListener('touchend', (e) => {
                e.preventDefault();
                shootJoystickActive = false;
                resetShootJoystick();
            });

            // Mouse events for desktop testing
            moveBase.addEventListener('mousedown', (e) => {
                moveJoystickActive = true;
                updateMoveJoystick(e);
            });

            document.addEventListener('mousemove', (e) => {
                if (moveJoystickActive) {
                    updateMoveJoystick(e);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (moveJoystickActive) {
                    moveJoystickActive = false;
                    resetMoveJoystick();
                }
            });

            shootBase.addEventListener('mousedown', (e) => {
                shootJoystickActive = true;
                updateShootJoystick(e);
            });

            document.addEventListener('mousemove', (e) => {
                if (shootJoystickActive) {
                    updateShootJoystick(e);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (shootJoystickActive) {
                    shootJoystickActive = false;
                    resetShootJoystick();
                }
            });
        }

        function updateMoveJoystick(event) {
            const base = document.getElementById('joystick-base');
            const stick = document.getElementById('joystick-stick');
            const rect = base.getBoundingClientRect();
            const baseCenterX = rect.left + rect.width / 2;
            const baseCenterY = rect.top + rect.height / 2;

            let clientX, clientY;

            if (event.type.includes('touch')) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const deltaX = clientX - baseCenterX;
            const deltaY = clientY - baseCenterY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = rect.width / 2;

            // Calculate normalized direction vector
            if (distance > maxDistance) {
                moveJoystick.x = deltaX / distance;
                moveJoystick.y = deltaY / distance;
                moveJoystick.magnitude = 1;

                // Position stick at edge
                stick.style.transform = `translate(${moveJoystick.x * maxDistance}px, ${moveJoystick.y * maxDistance}px)`;
            } else {
                moveJoystick.x = deltaX / maxDistance;
                moveJoystick.y = deltaY / maxDistance;
                moveJoystick.magnitude = distance / maxDistance;

                // Position stick at touch point
                stick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            }
        }

        function updateShootJoystick(event) {
            const base = document.getElementById('shoot-joystick-base');
            const stick = document.getElementById('shoot-joystick-stick');
            const rect = base.getBoundingClientRect();
            const baseCenterX = rect.left + rect.width / 2;
            const baseCenterY = rect.top + rect.height / 2;

            let clientX, clientY;

            if (event.type.includes('touch')) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const deltaX = clientX - baseCenterX;
            const deltaY = clientY - baseCenterY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = rect.width / 2;

            // Calculate normalized direction vector
            if (distance > maxDistance) {
                shootJoystick.x = deltaX / distance;
                shootJoystick.y = deltaY / distance;
                shootJoystick.magnitude = 1;

                // Position stick at edge
                stick.style.transform = `translate(${shootJoystick.x * maxDistance}px, ${shootJoystick.y * maxDistance}px)`;
            } else {
                shootJoystick.x = deltaX / maxDistance;
                shootJoystick.y = deltaY / maxDistance;
                shootJoystick.magnitude = distance / maxDistance;

                // Position stick at touch point
                stick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            }

            // Auto-shoot when joystick is active
            if (shootJoystickActive && player && player.shootCooldown <= 0) {
                const targetX = player.x + player.size / 2 + shootJoystick.x * player.laserRange;
                const targetY = player.y + player.size / 2 + shootJoystick.y * player.laserRange;
                playerShoot(targetX, targetY);
            }
        }

        function resetMoveJoystick() {
            moveJoystick = { x: 0, y: 0, magnitude: 0 };
            document.getElementById('joystick-stick').style.transform = 'translate(0px, 0px)';
        }

        function resetShootJoystick() {
            shootJoystick = { x: 0, y: 0, magnitude: 0 };
            document.getElementById('shoot-joystick-stick').style.transform = 'translate(0px, 0px)';
        }

        // Update the handleInputFrame function to use joystick input
        function handleInputFrame() {
            if (!player) return;

            let inputX = 0, inputY = 0;

            // Keyboard input (existing)
            if (keysPressed['arrowup'] || keysPressed['w']) inputY -= 1;
            if (keysPressed['arrowdown'] || keysPressed['s']) inputY += 1;
            if (keysPressed['arrowleft'] || keysPressed['a']) inputX -= 1;
            if (keysPressed['arrowright'] || keysPressed['d']) inputX += 1;

            // Joystick input (new)
            if (moveJoystickActive && moveJoystick.magnitude > 0.1) {
                inputX += moveJoystick.x;
                inputY += moveJoystick.y;
            }

            // Normalize input if both keyboard and joystick are used
            if (inputX !== 0 && inputY !== 0) {
                const length = Math.sqrt(inputX * inputX + inputY * inputY);
                inputX /= length;
                inputY /= length;
            }

            if (inputX !== 0 || inputY !== 0) {
                const oldX = player.x, oldY = player.y;
                player.x += inputX * player.speed;
                player.y += inputY * player.speed;

                player.x = Math.max(0, Math.min(player.x, MAP_WIDTH - player.size));
                player.y = Math.max(0, Math.min(player.y, MAP_HEIGHT - player.size));

                for (let obs of obstacles) {
                    if (checkCollisionWithRect(player, obs)) {
                        player.x = oldX;
                        player.y = oldY;
                        break;
                    }
                }
            }

            // Check for health pack collision
           // checkHealthPackCollision(player);

            if (player.shootCooldown > 0) player.shootCooldown--;
        }
        /************************************************** */
        //end joystick implementation
        /************************************************** */
        function checkGameEnd() {
            const alivePlayers = players.filter(p => p.currentHp > 0);

            console.log("Game end check - Alive players:", alivePlayers.length);
            console.log("Total players:", players.length);
            players.forEach((p, i) => {
                console.log(`Player ${i}: HP=${p.currentHp}, isHuman=${p.isHuman}, isBot=${p.isBot}`);
            });

            if (gameModes[currentGameMode].teams) {
                const redAlive = alivePlayers.filter(p => p.team === 'red').length;
                const blueAlive = alivePlayers.filter(p => p.team === 'blue').length;
                console.log("Team check - Red:", redAlive, "Blue:", blueAlive);

                if (redAlive === 0 || blueAlive === 0) {
                    console.log("Team game ended!");
                    endGame((redAlive > 0 ? 'Red' : 'Blue') + ' Team Wins!', redAlive > 0);
                }
            } else {
                console.log("Showdown check - Alive:", alivePlayers.length);
                if (alivePlayers.length === 1) {
                    console.log("Showdown ended with 1 player left!");
                    endGame(alivePlayers[0].isHuman ? 'You Win!' : 'Game Over!', alivePlayers[0].isHuman);
                } else if (alivePlayers.length === 0) {
                    console.log("Showdown ended with 0 players - Draw!");
                    endGame('Draw!', false);
                }
            }
        }

        // Game loop
        function gameLoop() {
            if (!gameStarted) return;

            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            updateCamera();
            handleInputFrame();

            // REMOVED: healing cooldown updates since we simplified the system

            updateAllBots();
            updateLasers();
            checkGameEnd();

            drawBackground();
            drawObstacles();
           // drawHealthPacks();
            drawPlayers();
            drawLasers();
            drawHUD();

            requestAnimationFrame(gameLoop);
        }

        // UI Functions
        function showCoins() {
            document.getElementById('coins-display').innerHTML =
                `💰 Coins: ${playerCoins}<br>🏆 Level: ${playerLevel}`;
        }

        function hideAllUI() {
            document.querySelector('.guide').style.display = 'none';
            document.querySelector('.menu').style.display = 'none';
            document.getElementById('joystick-container').style.display = 'none';
            document.getElementById('shoot-joystick-container').style.display = 'none';
            document.getElementById('game-modes-container').style.display = 'none';
            document.getElementById('skins-container').style.display = 'none';
            document.getElementById('player-menu').style.display = 'none';
            document.getElementById('game-over-overlay').style.display = 'none';
        }

        function showAllUI() {
            document.querySelector('.guide').style.display = 'block';
            document.querySelector('.menu').style.display = 'flex';
            document.getElementById('joystick-container').style.display = 'block';
            document.getElementById('shoot-joystick-container').style.display = 'block';
            document.getElementById('game-over-overlay').style.display = 'none';
        }

        function startGame() {
            hideAllUI();
            setupGameMode(currentGameMode);
            gameStarted = true;
            gameLoop();
        }

        // Bazaar System
        function initBazaar() {
            document.getElementById('shop-btn').addEventListener('click', () => {
                document.getElementById('skins-container').style.display = 'block';
                renderBazaarItems();
            });

            document.getElementById('close-bazaar').addEventListener('click', () => {
                document.getElementById('skins-container').style.display = 'none';
            });
        }

        function renderBazaarItems() {
            const container = document.getElementById('bazaar-items');
            container.innerHTML = '';

            Object.values(playersData).forEach(playerData => {
                if (playerData.id === 'default') return;

                const isUnlocked = unlockedPlayers.includes(playerData.id);
                const canAfford = playerCoins >= playerData.price;

                const card = document.createElement('div');
                card.className = 'skin-card';

                // Use image if available, otherwise use color
                const imageHtml = playerData.img ?
                    `<img src="${playerData.img}" class="skin-img" alt="${playerData.name}"
                                      onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                      style="width:100%; height:120px; object-fit:cover; border-radius:10px;">` :
                    '';

                const fallbackHtml = `<div style="background:${playerData.color}; height:120px; border-radius:10px;
                                                  display:${playerData.img ? 'none' : 'flex'}; align-items:center;
                                                  justify-content:center; color:white; font-weight:bold;">
                                                  ${playerData.name}</div>`;

                card.innerHTML = `
                                ${imageHtml}
                                ${fallbackHtml}
                                <h3>${playerData.name}</h3>
                                <p>HP: ${playerData.hp} | Damage: ${playerData.laserDamage}</p>
                                <p>Speed: ${playerData.speed} | Range: ${playerData.laserRange}</p>
                                <p><strong>💰 ${playerData.price} coins</strong></p>
                                <button class="btn buy-btn" ${isUnlocked || !canAfford ? 'disabled' : ''}>
                                    ${isUnlocked ? '✅ Owned' : (!canAfford ? '❌ Need Coins' : 'Buy Now')}
                                </button>
                            `;

                const buyBtn = card.querySelector('.buy-btn');
                if (!isUnlocked && canAfford) {
                    buyBtn.addEventListener('click', () => buyPlayer(playerData.id));
                }

                container.appendChild(card);
            });
        }

        function buyPlayer(playerId) {
            const playerData = playersData[playerId];
            if (playerCoins >= playerData.price && !unlockedPlayers.includes(playerId)) {
                playerCoins -= playerData.price;
                unlockedPlayers.push(playerId);
                showLootboxPopup(`Unlocked ${playerData.name}!`);
                showCoins();
                renderBazaarItems();
            }
        }

        function showLootboxPopup(message) {
            document.getElementById('lootbox-content').textContent = message;
            document.getElementById('lootbox-popup').style.display = 'block';
            document.getElementById('lootbox-ok').onclick = () => {
                document.getElementById('lootbox-popup').style.display = 'none';
            };
        }

        // Player Menu
        function initPlayerMenu() {
            document.getElementById('switch-player-btn').addEventListener('click', () => {
                document.getElementById('player-menu').style.display = 'block';
                updatePlayerMenu();
            });

            document.getElementById('close-player-menu').addEventListener('click', () => {
                document.getElementById('player-menu').style.display = 'none';
            });
        }

        function updatePlayerMenu() {
            const container = document.getElementById('player-list');
            container.innerHTML = '';

            unlockedPlayers.forEach(playerId => {
                const playerData = playersData[playerId];
                const isSelected = selectedPlayerId === playerId;

                const card = document.createElement('div');
                card.className = 'skin-card';
                card.style.border = isSelected ? '3px solid #ffcc00' : '2px solid #ccc';
                card.style.background = isSelected ? 'rgba(255, 204, 0, 0.1)' : '';

                // Use image if available, otherwise use color
                const imageHtml = playerData.img ?
                    `<img src="${playerData.img}" class="skin-img" alt="${playerData.name}"
                                      onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                                      style="width:100%; height:120px; object-fit:cover; border-radius:10px;">` :
                    '';

                const fallbackHtml = `<div style="background:${playerData.color}; height:120px; border-radius:10px;
                                                  display:${playerData.img ? 'none' : 'flex'}; align-items:center;
                                                  justify-content:center; color:white; font-weight:bold;">
                                                  ${playerData.name}</div>`;

                card.innerHTML = `
                                ${imageHtml}
                                ${fallbackHtml}
                                <h3>${playerData.name}</h3>
                                <p>HP: ${playerData.hp} | Damage: ${playerData.laserDamage}</p>
                                <button class="btn select-btn" ${isSelected ? 'disabled' : ''}>
                                    ${isSelected ? '✅ Selected' : 'Select'}
                                </button>
                            `;

                const selectBtn = card.querySelector('.select-btn');
                if (!isSelected) {
                    selectBtn.addEventListener('click', () => {
                        selectedPlayerId = playerId;
                        updatePlayerMenu();
                        document.getElementById('player-menu').style.display = 'none';
                        showLootboxPopup(`Switched to ${playerData.name}!`);
                    });
                }

                container.appendChild(card);
            });
        }

        // Game Modes
        function initGameModes() {
            document.getElementById('game-mode-btn').addEventListener('click', () => {
                document.getElementById('game-modes-container').style.display = 'block';
            });

            document.getElementById('close-modes-btn').addEventListener('click', () => {
                document.getElementById('game-modes-container').style.display = 'none';
            });

            document.querySelectorAll('.mode-card').forEach(card => {
                card.addEventListener('click', () => {
                    document.querySelectorAll('.mode-card').forEach(c => c.style.background = '');
                    card.style.background = 'rgba(255, 204, 0, 0.3)';
                    currentGameMode = card.dataset.mode;
                });
            });
        }

        // Mouse shooting
        function initMouseShooting() {
            gameCanvas.addEventListener('mousedown', (e) => {
                if (!gameStarted || !player) return;
                const rect = gameCanvas.getBoundingClientRect();
                const targetX = e.clientX - rect.left + camera.x;
                const targetY = e.clientY - rect.top + camera.y;
                playerShoot(targetX, targetY);
            });
        }

        // Initialize everything
        function initGame() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            preloadImages(); // Preload images first
            initJoysticks(); // Add this line to initialize joysticks
            initGameModes();
            initMouseShooting();
            initBazaar();
            initPlayerMenu();
            showCoins();
            //hide joystick on first screen
            document.getElementById('joystick-container').style.display = 'none';
            document.getElementById('shoot-joystick-container').style.display = 'none';

            // Start game button
            document.getElementById('start-btn').addEventListener('click', startGame);

            // Return to menu button
            document.getElementById('return-to-menu').addEventListener('click', () => {
                showAllUI();
            });

            // Debug
            function setDebug(msg) {
                document.getElementById('debug-status').textContent = msg;
            }
            setDebug('Game Ready - Click Battle!');
            function debugGameState() {
                console.log("=== GAME STATE DEBUG ===");
                console.log("Game started:", gameStarted);
                console.log("Player:", player);
                console.log("Players alive:", players.filter(p => p.currentHp > 0).length);
                console.log("Lasers:", lasers.length);
                console.log("AI Lasers:", aiLasers.length);
                console.log("Health packs:", healthPacks.filter(p => p.active).length, "active");
                console.log("========================");
            }

            // You can call this from the console anytime by typing: debugGameState()
            window.debugGameState = debugGameState;
            console.log('Game initialized successfully');
        }

        // Start the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>